import dgl
import torch
import torch.nn.functional as F
from dgl.nn import GraphConv
from torch import nn
from torch.utils.data import DataLoader
from tqdm import tqdm

from dataset import MalwareDataset, _collate_fn, _collate_fn_pairs, PairMalwareDataset


# https://docs.dgl.ai/tutorials/blitz/5_graph_classification.html#define-model
class GCN(nn.Module):
    def __init__(self, in_feats, h_feats, num_classes):
        super(GCN, self).__init__()
        self.conv1 = GraphConv(in_feats, h_feats)
        self.conv2 = GraphConv(h_feats, h_feats)
        self.classify = nn.Linear(h_feats, num_classes)

    def forward(self, g, in_feat):
        h = self.conv1(g, in_feat)
        h = F.relu(h)
        h = self.conv2(g, h)
        g.ndata['h'] = h
        return self.classify(dgl.mean_nodes(g, 'h')), dgl.mean_nodes(g, 'h')


class SiameseGCN(nn.Module):
    def __init__(self, in_feats, h_feats, num_classes):
        super(SiameseGCN, self).__init__()
        self.conv1 = GraphConv(in_feats, h_feats)
        self.conv2 = GraphConv(h_feats, h_feats)
        self.linear = nn.Sequential(nn.Linear(h_feats, h_feats), nn.Sigmoid())
        self.out = nn.Linear(h_feats, 1)

    def single_forward(self, g, in_feat):
        h = self.conv1(g, in_feat)
        h = F.relu(h)
        h = self.conv2(g, h)
        g.ndata['h'] = h
        return self.linear(dgl.mean_nodes(g, 'h'))

    def forward(self, g1, in_feat1, g2, in_feat2):
        h1 = self.single_forward(g1, in_feat1)
        h2 = self.single_forward(g2, in_feat2)
        dis = torch.abs(h1 - h2)
        out = self.out(dis)
        return out


def training_gcn_model(heodo_path, trickbot_path, agenttesla_path, dridex_path, loki_path):
    mal_dataset = MalwareDataset(heodo_path, trickbot_path, agenttesla_path, dridex_path, loki_path)
    train_dataloader = DataLoader(mal_dataset, batch_size=1, collate_fn=_collate_fn, shuffle=True)
    model = GCN(28, 10, 5)
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)

    for epoch in range(20):
        for batched_graph, labels, sha256 in tqdm(train_dataloader, total=len(train_dataloader)):
            # Pay attention that currently the only feature used is the counts of instruction
            pred, hidden = model(batched_graph, batched_graph.ndata['diss_features'].float())
            loss = F.cross_entropy(pred, labels)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

    return model


def training_siamese_gcn_model(mal_dataset):
    pair_dataset = PairMalwareDataset(mal_dataset, 200000)
    pairs_train_dataloader = DataLoader(pair_dataset, batch_size=20, collate_fn=_collate_fn_pairs, shuffle=True)
    model = SiameseGCN(28, 10, 5)
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
    loss_fn = torch.nn.BCEWithLogitsLoss(size_average=True)

    for epoch in range(8):
        for batched_first, batched_second, batched_labels in tqdm(pairs_train_dataloader,
                                                                  total=len(pairs_train_dataloader)):
            out = model(batched_first, batched_first.ndata['diss_features'].float(), batched_second,
                        batched_second.ndata['diss_features'].float())
            loss = loss_fn(out, torch.reshape(batched_labels, (-1, 1)).float())

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

    return model
